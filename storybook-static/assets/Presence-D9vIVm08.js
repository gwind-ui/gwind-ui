import{r as O}from"./Primitive-BG2Gt-GN.js";import{r as d,w as E,q as S,l as C,c as U,d as P,v as b,C as w,h as _}from"./vue.esm-bundler-CDO2oHXK.js";import{d as x,i as D,c as F}from"./useForwardExpose-BfXw-hnz.js";function L(r,e){const o=d(r);function f(c){return e[o.value][c]??o.value}return{state:o,dispatch:c=>{o.value=f(c)}}}function R(r,e){var T;const o=d({}),f=d("none"),h=d(r),c=r.value?"mounted":"unmounted";let l;const i=((T=e.value)==null?void 0:T.ownerDocument.defaultView)??x,{state:m,dispatch:u}=L(c,{mounted:{UNMOUNT:"unmounted",ANIMATION_OUT:"unmountSuspended"},unmountSuspended:{MOUNT:"mounted",ANIMATION_END:"unmounted"},unmounted:{MOUNT:"mounted"}}),s=t=>{var n;if(D){const p=new CustomEvent(t,{bubbles:!1,cancelable:!1});(n=e.value)==null||n.dispatchEvent(p)}};E(r,async(t,n)=>{var A;const p=n!==t;if(await S(),p){const M=f.value,v=y(e.value);t?(u("MOUNT"),s("enter"),v==="none"&&s("after-enter")):v==="none"||v==="undefined"||((A=o.value)==null?void 0:A.display)==="none"?(u("UNMOUNT"),s("leave"),s("after-leave")):n&&M!==v?(u("ANIMATION_OUT"),s("leave")):(u("UNMOUNT"),s("after-leave"))}},{immediate:!0});const a=t=>{const n=y(e.value),p=n.includes(CSS.escape(t.animationName)),A=m.value==="mounted"?"enter":"leave";if(t.target===e.value&&p&&(s(`after-${A}`),u("ANIMATION_END"),!h.value)){const M=e.value.style.animationFillMode;e.value.style.animationFillMode="forwards",l=i==null?void 0:i.setTimeout(()=>{var v;((v=e.value)==null?void 0:v.style.animationFillMode)==="forwards"&&(e.value.style.animationFillMode=M)})}t.target===e.value&&n==="none"&&u("ANIMATION_END")},N=t=>{t.target===e.value&&(f.value=y(e.value))},g=E(e,(t,n)=>{t?(o.value=getComputedStyle(t),t.addEventListener("animationstart",N),t.addEventListener("animationcancel",a),t.addEventListener("animationend",a)):(u("ANIMATION_END"),l!==void 0&&(i==null||i.clearTimeout(l)),n==null||n.removeEventListener("animationstart",N),n==null||n.removeEventListener("animationcancel",a),n==null||n.removeEventListener("animationend",a))},{immediate:!0}),I=E(m,()=>{const t=y(e.value);f.value=m.value==="mounted"?t:"none"});return C(()=>{g(),I()}),{isPresent:U(()=>["mounted","unmountSuspended"].includes(m.value))}}function y(r){return r&&getComputedStyle(r).animationName||"none"}var V=P({name:"Presence",props:{present:{type:Boolean,required:!0},forceMount:{type:Boolean}},slots:{},setup(r,{slots:e,expose:o}){var u;const{present:f,forceMount:h}=b(r),c=d(),{isPresent:l}=R(f,c);o({present:l});let i=e.default({present:l.value});i=O(i||[]);const m=w();if(i&&(i==null?void 0:i.length)>1){const s=(u=m==null?void 0:m.parent)!=null&&u.type.name?`<${m.parent.type.name} />`:"component";throw new Error([`Detected an invalid children for \`${s}\` for  \`Presence\` component.`,"","Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.","You can apply a few solutions:",["Provide a single child element so that `presence` directive attach correctly.","Ensure the first child is an actual element instead of a raw text node or comment node."].map(a=>`  - ${a}`).join(`
`)].join(`
`))}return()=>h.value||f.value||l.value?_(e.default({present:l.value})[0],{ref:s=>{const a=F(s);return typeof(a==null?void 0:a.hasAttribute)>"u"||(a!=null&&a.hasAttribute("data-reka-popper-content-wrapper")?c.value=a.firstElementChild:c.value=a),a}}):null}});export{V as P};
